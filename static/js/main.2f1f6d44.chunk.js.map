{"version":3,"sources":["components/Settings.tsx","components/Header.tsx","logic/GeneticNode.ts","components/node/Node.tsx","components/GeneticVisualizer.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["PopulationSize","MutationType","getDefaultSettings","endColor","populationSize","Medium","mutationType","Gradual","mutationChance","decreaseMutation","matingPoolPercent","Settings","state","handleVisualize","_","props","switchToVisualize","handleMutationTypeChange","e","currentTarget","value","Invert","setState","handlePopulationSizeChange","Small","Large","handleColorChange","hexToRgb","handleCheckBoxChange","checked","handleMutationChanceChange","handleMatingPoolPercentChange","hex","result","exec","parseInt","className","Card","Header","as","Body","Form","Group","controlId","Label","style","fontWeight","Control","type","onChange","this","defaultValue","Check","label","min","max","step","Button","variant","onClick","React","Component","Navbar","bg","expand","Brand","Toggle","aria-controls","Collapse","id","Nav","Text","generationNumber","inline","sortByFitness","nextGeneration","switchToSettings","GeneticNode","colorVector","targetColor","difference","i","Math","sqrt","reduce","item","pow","mutate","x","getRandomInt","mutation","getMutationChance","random","ceil","floor","parent1","parent2","offspring","parent1Influence","nodes","slice","round","length","sort","a","b","getDistanceFromTarget","Node","color","geneticNode","height","width","backgroundColor","GeneticVisualizer","grid","settings","times","flattenedNodes","getFlattenedNodes","matingPool","getMatingPool","numCrossovers","getNextPopulation","unFlattenNodes","getInitialGrid","size","getGridSize","row","currentRow","col","push","nextPopulation","Array","from","parents","getParents","crossover","mutateOffspring","mutateGradual","mutateInvert","index1","index2","j","index","Container","fluid","map","rowIdx","Row","key","node","nodeIdx","Col","App","isSettings","settingsState","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.2f1f6d44.chunk.js","sourcesContent":["import React from \"react\";\nimport Form from \"react-bootstrap/Form\";\nimport Button from \"react-bootstrap/Button\";\nimport Card from \"react-bootstrap/Card\";\n\nexport interface SettingsState {\n  endColor: [number, number, number];\n  populationSize: PopulationSize;\n  mutationType: MutationType;\n  mutationChance: number;\n  decreaseMutation: boolean;\n  matingPoolPercent: number;\n}\n\ntype SettingsProps = {\n  switchToVisualize: Function;\n};\n\nexport enum PopulationSize {\n  Small,\n  Medium,\n  Large,\n}\n\nexport enum MutationType {\n  Gradual,\n  Invert,\n}\n\nexport function getDefaultSettings(): SettingsState {\n  return {\n    endColor: [0, 0, 0],\n    populationSize: PopulationSize.Medium,\n    mutationType: MutationType.Gradual,\n    mutationChance: 0.3,\n    decreaseMutation: false,\n    matingPoolPercent: 0.25,\n  };\n}\n\nexport default class Settings extends React.Component<\n  SettingsProps,\n  SettingsState\n> {\n  state: SettingsState = getDefaultSettings();\n\n  private handleVisualize = (_: React.FormEvent) => {\n    this.props.switchToVisualize(this.state);\n  };\n\n  private handleMutationTypeChange = (\n    e: React.ChangeEvent<HTMLSelectElement>\n  ) => {\n    let mutationType = MutationType.Gradual;\n    switch (e.currentTarget.value) {\n      case \"Gradual\": {\n        mutationType = MutationType.Gradual;\n        break;\n      }\n      case \"Invert\": {\n        mutationType = MutationType.Invert;\n        break;\n      }\n    }\n    this.setState({\n      mutationType: mutationType,\n    });\n  };\n\n  private handlePopulationSizeChange = (\n    e: React.ChangeEvent<HTMLSelectElement>\n  ) => {\n    let populationSize = PopulationSize.Medium;\n    switch (e.currentTarget.value) {\n      case \"Small\": {\n        populationSize = PopulationSize.Small;\n        break;\n      }\n      case \"Medium\": {\n        populationSize = PopulationSize.Medium;\n        break;\n      }\n      case \"Large\": {\n        populationSize = PopulationSize.Large;\n        break;\n      }\n    }\n    this.setState({\n      populationSize: populationSize,\n    });\n  };\n\n  private handleColorChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    this.setState({ endColor: this.hexToRgb(e.currentTarget.value) });\n  };\n\n  private handleCheckBoxChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    this.setState({ decreaseMutation: e.currentTarget.checked });\n  };\n\n  private handleMutationChanceChange = (\n    e: React.ChangeEvent<HTMLSelectElement>\n  ) => {\n    this.setState({\n      mutationChance: +e.currentTarget.value,\n    });\n  };\n\n  private handleMatingPoolPercentChange = (\n    e: React.ChangeEvent<HTMLSelectElement>\n  ) => {\n    this.setState({\n      matingPoolPercent: +e.currentTarget.value,\n    });\n  };\n\n  private hexToRgb(hex: string): [number, number, number] {\n    var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return [\n      parseInt(result![1], 16),\n      parseInt(result![2], 16),\n      parseInt(result![3], 16),\n    ];\n  }\n\n  render() {\n    return (\n      <div className=\"container\">\n        <Card>\n          <Card.Header as=\"h5\">Genetic Visualizer</Card.Header>\n          <Card.Body>\n            <Form>\n              <Form.Group controlId=\"formEndColor\">\n                <Form.Label style={{ fontWeight: \"bold\" }}>\n                  The color to converge to:\n                </Form.Label>\n                <Form.Control type=\"color\" onChange={this.handleColorChange} />\n              </Form.Group>\n              <Form.Group controlId=\"formPopulationSize\">\n                <Form.Label style={{ fontWeight: \"bold\" }}>\n                  Population Size:\n                </Form.Label>\n                <Form.Control\n                  as=\"select\"\n                  defaultValue=\"Medium\"\n                  onChange={this.handlePopulationSizeChange}\n                >\n                  <option>Small</option>\n                  <option>Medium</option>\n                  <option>Large</option>\n                </Form.Control>\n              </Form.Group>\n              <Form.Group controlId=\"formMutationType\">\n                <Form.Label style={{ fontWeight: \"bold\" }}>\n                  Mutation Type:\n                </Form.Label>\n                <Form.Control\n                  as=\"select\"\n                  defaultValue=\"Gradual\"\n                  onChange={this.handleMutationTypeChange}\n                >\n                  <option>Gradual</option>\n                  <option>Invert</option>\n                </Form.Control>\n              </Form.Group>\n              <Form.Group controlId=\"formCheck\">\n                <Form.Check\n                  type=\"checkbox\"\n                  label=\"Decrease mutation chance over generations\"\n                  onChange={this.handleCheckBoxChange}\n                  checked={this.state.decreaseMutation}\n                />\n              </Form.Group>\n              <Form.Group controlId=\"formMutationRange\">\n                <Form.Label>\n                  <span style={{ fontWeight: \"bold\" }}>Mutation Chance:</span>{\" \"}\n                  {this.state.mutationChance}\n                </Form.Label>\n                <Form.Control\n                  type=\"range\"\n                  min=\"0\"\n                  max=\"1\"\n                  step=\"0.05\"\n                  value={this.state.mutationChance}\n                  onChange={this.handleMutationChanceChange}\n                />\n              </Form.Group>\n              <Form.Group controlId=\"formMatingPoolRange\">\n                <Form.Label>\n                  <span style={{ fontWeight: \"bold\" }}>\n                    Percentage of population in mating pool:\n                  </span>{\" \"}\n                  {this.state.matingPoolPercent}\n                </Form.Label>\n                <Form.Control\n                  type=\"range\"\n                  min=\"0\"\n                  max=\"1\"\n                  step=\"0.05\"\n                  value={this.state.matingPoolPercent}\n                  onChange={this.handleMatingPoolPercentChange}\n                />\n              </Form.Group>\n              <Button variant=\"primary\" onClick={this.handleVisualize}>\n                Visualize\n              </Button>\n            </Form>\n          </Card.Body>\n        </Card>\n      </div>\n    );\n  }\n}\n","import React from \"react\";\nimport Navbar from \"react-bootstrap/Navbar\";\nimport Nav from \"react-bootstrap/Nav\";\nimport Form from \"react-bootstrap/Form\";\nimport Button from \"react-bootstrap/Button\";\n\ntype HeaderProps = {\n  generationNumber: number;\n  mutationChance: number;\n  nextGeneration: Function;\n  sortByFitness: Function;\n  switchToSettings: Function;\n};\n\nexport default class Header extends React.Component<HeaderProps> {\n  render() {\n    return (\n      <Navbar bg=\"light\" expand=\"lg\">\n        <Navbar.Brand>Genetic Visualizer</Navbar.Brand>\n        <Navbar.Toggle aria-controls=\"basic-navbar-nav\" />\n        <Navbar.Collapse id=\"basic-navbar-nav\">\n          <Nav className=\"mr-auto\">\n            <Navbar.Text className=\"mr-sm-2\">\n              Generation Number: {this.props.generationNumber}\n            </Navbar.Text>\n            <Navbar.Text className=\"mr-sm-2\">\n              Mutation Chance: {this.props.mutationChance}\n            </Navbar.Text>\n          </Nav>\n          <Form inline>\n            <Button\n              className=\"mr-sm-2\"\n              onClick={(_) => this.props.sortByFitness()}\n            >\n              Sort by fitness\n            </Button>\n            <Button\n              className=\"mr-sm-2\"\n              onClick={(_) => this.props.nextGeneration()}\n            >\n              Next Generation\n            </Button>\n            <Button\n              className=\"mr-sm-2\"\n              onClick={(_) => this.props.nextGeneration(10)}\n            >\n              Next Generation (x10)\n            </Button>\n            <Button\n              className=\"mr-sm-2\"\n              variant=\"dark\"\n              onClick={(_) => this.props.switchToSettings()}\n            >\n              Reset\n            </Button>\n          </Form>\n        </Navbar.Collapse>\n      </Navbar>\n    );\n  }\n}\n","/**\n * The individuals in the population.\n */\nexport default class GeneticNode {\n  colorVector: [number, number, number];\n  constructor() {\n    // Initialize to white.\n    this.colorVector = [255, 255, 255];\n  }\n\n  /**\n   * Offspring's colorVector determined by linear interpolation between both\n   * parents' color vectors. This is done for each color channel.\n   *\n   * @param parent1  The first parent\n   * @param parent2  The second parent\n   *\n   * @returns The offspring of the two parents\n   */\n  static crossover(parent1: GeneticNode, parent2: GeneticNode): GeneticNode {\n    let offspring = new GeneticNode();\n    for (let i = 0; i < 3; i++) {\n      let parent1Influence = Math.random();\n      offspring.colorVector[i] =\n        parent1.colorVector[i] * parent1Influence +\n        parent2.colorVector[i] * (1 - parent1Influence);\n    }\n    return offspring;\n  }\n\n  /**\n   * Selects the top matingPoolPercent of the population based on fitness.\n   *\n   * @param nodes  The genetic nodes to select from\n   * @param targetColor  The color to optimize for\n   * @param matingPoolPercent  The percent of population chosen for mating\n   *\n   * @returns The nodes that will be used for mating\n   */\n  static getMatingPool(\n    nodes: GeneticNode[],\n    targetColor: [number, number, number],\n    matingPoolPercent: number\n  ): GeneticNode[] {\n    this.sortByFitness(nodes, targetColor);\n    return nodes.slice(0, Math.round(nodes.length * matingPoolPercent));\n  }\n\n  /**\n   * Sorts the nodes by fitness, decsecnding.\n   */\n  static sortByFitness(\n    nodes: GeneticNode[],\n    targetColor: [number, number, number]\n  ) {\n    nodes.sort((a, b) =>\n      a.getDistanceFromTarget(targetColor) <\n      b.getDistanceFromTarget(targetColor)\n        ? -1\n        : 1\n    );\n  }\n\n  /**\n   * Used to determine the fitness of an individual by computing the\n   * euclidean distance between the node's color vector and the target color\n   * vector. Smaller number implies more fit.\n   *\n   * @param targetColor  The color to optimize for\n   *\n   * @returns The euclidean distance between this.colorVector and targetColor\n   */\n  getDistanceFromTarget(targetColor: [number, number, number]): number {\n    let difference = [0, 0, 0];\n    for (let i = 0; i < 3; i++) {\n      difference[i] = targetColor[i] - this.colorVector[i];\n    }\n    return Math.sqrt(\n      difference.reduce((result, item) => {\n        return result + Math.pow(item, 2);\n      }, 0)\n    );\n  }\n\n  /**\n   * Mutation function that adds a value between -50 and 50 to a color channel.\n   *\n   * @param generationNumber  The generation number\n   * @param mutationChance  The chance of mutation\n   *\n   * @returns The updated mutation chance\n   */\n  mutateGradual(generationNumber: number, mutationChance: number): number {\n    return this.mutate(\n      generationNumber,\n      mutationChance,\n      (x: number) => x + this.getRandomInt(-50, 50)\n    );\n  }\n\n  /**\n   * Mutation function that inverts a color channel.\n   *\n   * @param generationNumber  The generation number\n   * @param mutationChance  The chance of mutation\n   *\n   * @returns The updated mutation chance\n   */\n  mutateInvert(generationNumber: number, mutationChance: number): number {\n    return this.mutate(\n      generationNumber,\n      mutationChance,\n      (x: number) => 255 - x\n    );\n  }\n\n  /**\n   * Executes mutation function onto each colour channel if a mutation occurs.\n   *\n   * @param generationNumber  The generation number\n   * @param mutationChance  The chance of mutation\n   * @param mutation  The function to be used for mutation\n   *\n   * @returns The updated mutation chance\n   */\n  private mutate(\n    generationNumber: number,\n    mutationChance: number,\n    mutation: Function\n  ): number {\n    mutationChance = this.getMutationChance(mutationChance, generationNumber);\n    for (let i = 0; i < 3; i++) {\n      let value = Math.random();\n      if (value <= mutationChance) {\n        //this.colorVector[i] = 255 - this.colorVector[i];\n        this.colorVector[i] = mutation(this.colorVector[i]);\n        if (this.colorVector[i] > 255) {\n          this.colorVector[i] = 255;\n        } else if (this.colorVector[i] < 0) {\n          this.colorVector[i] = 0;\n        }\n      }\n    }\n    return mutationChance;\n  }\n\n  /**\n   * Gets a pseudo random integer between the given range.\n   *\n   * @param min  The lower bound inclusive\n   * @param max The upper bound inclusive\n   *\n   * @returns The pseudo random number\n   */\n  private getRandomInt(min: number, max: number): number {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  /**\n   * As the generation number goes up the mutation chance should be decreased.\n   * If generationNumber is -1 then it is implied that the user doesn't want to\n   * lower the mutation value as generation increase.\n   *\n   * @param mutationChance The chance of mutation\n   * @param generationNumber  The generation number\n   *\n   * @returns The updated mutation chance\n   */\n  private getMutationChance(\n    mutationChance: number,\n    generationNumber: number\n  ): number {\n    if (generationNumber !== -1) {\n      return mutationChance / generationNumber;\n    }\n    return mutationChance;\n  }\n}\n","import React from \"react\";\nimport \"./Node.css\";\nimport GeneticNode from \"../../logic/GeneticNode\";\nimport { PopulationSize } from \"../Settings\";\n\ntype NodeProps = {\n  geneticNode: GeneticNode;\n  populationSize: PopulationSize;\n};\n\nexport default class Node extends React.Component<NodeProps> {\n  render() {\n    const color = this.props.geneticNode.colorVector;\n    let height = \"50px\";\n    let width = \"50px\";\n    switch (this.props.populationSize) {\n      case PopulationSize.Small: {\n        height = \"100px\";\n        width = \"100px\";\n        break;\n      }\n      case PopulationSize.Medium: {\n        height = \"50px\";\n        width = \"50px\";\n        break;\n      }\n      case PopulationSize.Large: {\n        height = \"15px\";\n        width = \"15px\";\n        break;\n      }\n    }\n\n    return (\n      <div\n        className=\"node\"\n        style={{\n          backgroundColor: `rgb(${color[0]}, ${color[1]},${color[2]})`,\n          height: height,\n          width: width,\n        }}\n      ></div>\n    );\n  }\n}\n","import React from \"react\";\nimport Header from \"./Header\";\nimport GeneticNode from \"../logic/GeneticNode\";\nimport { SettingsState, PopulationSize, MutationType } from \"./Settings\";\nimport Node from \"./node/Node\";\nimport Container from \"react-bootstrap/Container\";\nimport Row from \"react-bootstrap/Row\";\nimport Col from \"react-bootstrap/Col\";\n\ntype VisualizerProps = {\n  settings: SettingsState;\n  switchToSettings: Function;\n};\n\ntype VisualizerState = {\n  grid: GeneticNode[][];\n  generationNumber: number;\n  mutationChance: number;\n};\n\nexport default class GeneticVisualizer extends React.Component<\n  VisualizerProps,\n  VisualizerState\n> {\n  state: VisualizerState = {\n    grid: [],\n    generationNumber: 1,\n    mutationChance: this.props.settings.mutationChance,\n  };\n\n  componentDidMount() {\n    this.setState({\n      grid: this.getInitialGrid(),\n    });\n  }\n\n  /**\n   * Entry point for gettting the next generation of nodes.\n   *\n   * @param times  The number of generations to acquire before updating grid\n   */\n  public nextGeneration = (times = 1) => {\n    let grid = this.state.grid;\n    let flattenedNodes = this.getFlattenedNodes(grid);\n    let generationNumber = this.state.generationNumber;\n    for (let i = 0; i < times; i++) {\n      let matingPool = GeneticNode.getMatingPool(\n        flattenedNodes,\n        this.props.settings.endColor,\n        this.props.settings.matingPoolPercent\n      );\n      // Keeps the population size constant.\n      let numCrossovers = flattenedNodes.length - matingPool.length;\n      flattenedNodes = this.getNextPopulation(\n        matingPool,\n        numCrossovers,\n        generationNumber\n      );\n      generationNumber++;\n    }\n    grid = this.unFlattenNodes(flattenedNodes);\n    this.setState({\n      grid: grid,\n      generationNumber: this.state.generationNumber + times,\n    });\n  };\n\n  /**\n   * Sorts the nodes in the grid by their fitness.\n   */\n  public sortByFitness = () => {\n    let endColor = this.props.settings.endColor;\n    let flattenedNodes = this.getFlattenedNodes(this.state.grid);\n    GeneticNode.sortByFitness(flattenedNodes, endColor);\n    this.setState({\n      grid: this.unFlattenNodes(flattenedNodes),\n    });\n  };\n\n  /**\n   * Gets the next population of nodes by creating offspring from the given\n   * mating pool.\n   *\n   * @param matingPool  The genetic nodes to get parents from\n   * @param numCrossovers  The number of cross overs to perform\n   * @param generationNumber  The generation number\n   *\n   * @returns The new population\n   */\n  private getNextPopulation(\n    matingPool: GeneticNode[],\n    numCrossovers: number,\n    generationNumber: number\n  ): GeneticNode[] {\n    let nextPopulation = Array.from(matingPool);\n    for (let i = 0; i < numCrossovers; i++) {\n      let parents = this.getParents(matingPool);\n      let offspring = GeneticNode.crossover(parents[0], parents[1]);\n      let mutationChance = this.mutateOffspring(offspring, generationNumber);\n      this.setState({ mutationChance: mutationChance });\n      nextPopulation.push(offspring);\n    }\n    return nextPopulation;\n  }\n\n  /**\n   * Mutates the given offspring based on mutationType.\n   *\n   * @param offspring  The new genetic node\n   * @param generationNumber  The generation number\n   *\n   * @returns The updated mutation chance\n   */\n  private mutateOffspring(\n    offspring: GeneticNode,\n    generationNumber: number\n  ): number {\n    switch (this.props.settings.mutationType) {\n      case MutationType.Gradual: {\n        return offspring.mutateGradual(\n          this.props.settings.decreaseMutation ? generationNumber : -1,\n          this.props.settings.mutationChance\n        );\n      }\n      case MutationType.Invert: {\n        return offspring.mutateInvert(\n          this.props.settings.decreaseMutation ? generationNumber : -1,\n          this.props.settings.mutationChance\n        );\n      }\n    }\n  }\n\n  /**\n   * Retrieves two random parents from the given mating pool.\n   *\n   * @param matingPool  The mating pool to choose parents from\n   *\n   * @returns The two chosen parents in an array of length 2\n   */\n  private getParents(matingPool: GeneticNode[]): [GeneticNode, GeneticNode] {\n    let index1 = Math.floor(Math.random() * matingPool.length);\n    let index2 = Math.floor(Math.random() * matingPool.length);\n    while (index2 === index1) {\n      index2 = Math.floor(Math.random() * matingPool.length);\n    }\n    return [matingPool[index1], matingPool[index2]];\n  }\n\n  /**\n   * Converts the 2d array of genetic nodes into a 1d array of genetic nodes.\n   *\n   * @param nodes  The nodes to flatten\n   *\n   * @returns The flattened nodes\n   */\n  private getFlattenedNodes(nodes: GeneticNode[][]): GeneticNode[] {\n    let flattenedNodes: GeneticNode[] = [];\n    for (let i = 0; i < nodes.length; i++) {\n      for (let j = 0; j < nodes[i].length; j++) {\n        flattenedNodes.push(nodes[i][j]);\n      }\n    }\n    return flattenedNodes;\n  }\n\n  /**\n   * Converts 1d array of genetic nodes into a 2d array of genetic nodes\n   * into the size it was initially set to.\n   *\n   * @param nodes  The nodes to unflatten\n   *\n   * @returns The nodes in a 2d array\n   */\n  private unFlattenNodes(nodes: GeneticNode[]): GeneticNode[][] {\n    let size = this.state.grid.length;\n    let index = 0;\n    let grid = [];\n    for (let i = 0; i < size; i++) {\n      let currentRow = [];\n      for (let j = 0; j < size; j++) {\n        currentRow.push(nodes[index]);\n        index++;\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  }\n\n  /**\n   * Gets the initial grid.\n   *\n   * @returns The created grid of genetic nodes\n   */\n  private getInitialGrid = (): GeneticNode[][] => {\n    let size = this.getGridSize();\n    const grid = [];\n    for (let row = 0; row < size; row++) {\n      const currentRow = [];\n      for (let col = 0; col < size; col++) {\n        currentRow.push(new GeneticNode());\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  };\n\n  /**\n   * Gets the grid size based on the chosen populationSize.\n   *\n   * @returns The grid size\n   */\n  private getGridSize(): number {\n    switch (this.props.settings.populationSize) {\n      case PopulationSize.Small: {\n        return 10;\n      }\n      case PopulationSize.Medium: {\n        return 20;\n      }\n      case PopulationSize.Large: {\n        return 36;\n      }\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        <Header\n          generationNumber={this.state.generationNumber}\n          mutationChance={this.state.mutationChance}\n          nextGeneration={this.nextGeneration}\n          sortByFitness={this.sortByFitness}\n          switchToSettings={this.props.switchToSettings}\n        />\n        <Container fluid=\"sm\">\n          {this.state.grid.map((row, rowIdx) => {\n            return (\n              <Row key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  return (\n                    <Col>\n                      <Node\n                        key={`${rowIdx}-${nodeIdx}`}\n                        geneticNode={node}\n                        populationSize={this.props.settings.populationSize}\n                      ></Node>\n                    </Col>\n                  );\n                })}\n              </Row>\n            );\n          })}\n        </Container>\n      </div>\n    );\n  }\n}\n","import React from \"react\";\nimport Settings, {\n  getDefaultSettings,\n  SettingsState,\n} from \"./components/Settings\";\nimport GeneticVisualizer from \"./components/GeneticVisualizer\";\nimport \"./App.css\";\n\ntype AppState = {\n  isSettings: boolean;\n  settings: SettingsState;\n};\n\nclass App extends React.Component<{}, AppState> {\n  state: AppState = {\n    isSettings: true,\n    settings: getDefaultSettings(),\n  };\n\n  switchToVisualize = (settingsState: SettingsState) => {\n    this.setState({\n      isSettings: false,\n      settings: settingsState,\n    });\n  };\n\n  switchToSettings = () => {\n    this.setState({ isSettings: true });\n  };\n\n  render() {\n    if (this.state.isSettings) {\n      return <Settings switchToVisualize={this.switchToVisualize} />;\n    } else {\n      return (\n        <GeneticVisualizer\n          settings={this.state.settings}\n          switchToSettings={this.switchToSettings}\n        />\n      );\n    }\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}